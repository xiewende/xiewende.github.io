<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>马在棋盘上的概率</title>
      <link href="%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
      <url>%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/1.jpg"></p><p>大意的意思就是在一个棋盘上，马按照象棋中马走日的规则，可以选择走K此后，最后还是留在棋盘的概率。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p>首先一匹马在任意位置可以选择八个方向走动，称之为方向向量，分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] dx = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;    //方向导向数组</span><br><span class="line">int[] dy = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;</span><br></pre></td></tr></table></figure></li><li><p>其次由于棋盘是有限的，所以如果选择的步伐超出了棋盘，则视为无效。</p></li><li><p>现在给个例子，模拟一下其的走动方位，N=4，k=3，r=0，c=0</p><ul><li><p>1、一开始的时候，这匹马所在的位置</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/2.jpg"></p></li><li><p>2、走第一步的时候后可以选择的落脚点：只有两个方向是可以选择的呢，其余的都是超出了棋盘的范围</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/1-2.jpg"></p><p>走完第一步后的矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/3.jpg"></p></li><li><p>3、仿照上述过程，第二步的走向如下</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/4.jpg"></p><p>​     走完第二步后的矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/5.jpg"></p><p>​    </p></li><li><p>第三步可选的落脚点如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/6.jpg"></p><p>走完第三步后的矩阵：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/7.jpg"></p></li><li><p>到这里，就已经完成了这匹马在棋盘上面的全部可能走法了，最后一个还有 2+2+6+6+2+2 = 20次还留着棋盘上，所以概率就为 20 / 8 * 8 * 8</p></li></ul></li><li><p>状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[r][c][steps]:表示马在位置（r，c）移动了 steps 次后还留在棋盘上的概率</span><br></pre></td></tr></table></figure><p>根据马的移动，得到如下递归方程</p></li></ul><p>$$<br>dp[r][c][steps] = \sum_{dr，dc}dp[r+dr][c+dc][steps-1] / 8.0<br>$$</p><p>​        dr，dc就是上面说的方向向量的数组，根据这个递归处理的方程，我们可以采取一个二维数组进行编写，即一新一旧，一步一步更新这些数组，最后求和即可</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//力扣上的主函数</span><br><span class="line">public double knightProbability(int N, int K, int r, int c) &#123;</span><br><span class="line">       double[][] dp_old = new double[N][N]; //dp_old数组，dp[x][y]表示第i次到达dp[x][y]的方案数</span><br><span class="line">       double[][] dp_new = new double[N][N]; //dp_new数组，dp[i][j]表示第i+1次到达dp[x][y]的方案数</span><br><span class="line">       //初始化</span><br><span class="line">       dp_old[r][c] = 1;   //一开始的位置</span><br><span class="line">       for(int i = 0; i &lt; K; i++)&#123; //K次</span><br><span class="line">           for (int x = 0; x &lt; N; x++) &#123;</span><br><span class="line">               for (int y = 0; y &lt; N; y++) &#123;</span><br><span class="line">                   //四面八方累加dp</span><br><span class="line">                   dp_new[x][y] = computeSumFromDirection(dp_old, x, y);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //更新两个数组</span><br><span class="line">           dp_old = dp_new;</span><br><span class="line">           dp_new = new double[N][N];</span><br><span class="line">       &#125;</span><br><span class="line">       //遍历这个数组的总和就是落在棋盘内所有格子的方案数</span><br><span class="line">       double in = 0;</span><br><span class="line">       for (int x = 0; x &lt; N; x++) &#123;</span><br><span class="line">           for (int y = 0; y &lt; N; y++) &#123;</span><br><span class="line">               in += dp_old[x][y];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return in;</span><br><span class="line">   &#125;</span><br><span class="line">//每次的八个方向的走法，并且判断是否越界</span><br><span class="line">   public double computeSumFromDirection(double[][] dp_old, int x, int y)&#123;</span><br><span class="line">       double sum = 0;</span><br><span class="line">       int[] dx = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;    //方向导向数组</span><br><span class="line">       int[] dy = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;</span><br><span class="line">       for (int i = 0; i &lt; dx.length; i++)&#123;</span><br><span class="line">           if(!check(dp_old, x + dx[i], y + dy[i])) continue;</span><br><span class="line">           sum += dp_old[x + dx[i]][y + dy[i]];</span><br><span class="line">       &#125;</span><br><span class="line">       return sum / 8.0;</span><br><span class="line">   &#125;</span><br><span class="line">//给定位置判断是否越界</span><br><span class="line">   public boolean check(double[][] dp_old, int x, int y)&#123;     //越界判断</span><br><span class="line">       return x &gt;= 0 &amp;&amp; x &lt; dp_old.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; dp_old[0].length;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>学习使我快乐！！！</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划—两道有趣的题目"><a href="#动态规划—两道有趣的题目" class="headerlink" title="动态规划—两道有趣的题目"></a>动态规划—两道有趣的题目</h2><h3 id="one：eetcode-300最长递增子序列"><a href="#one：eetcode-300最长递增子序列" class="headerlink" title="one：eetcode 300最长递增子序列"></a>one：eetcode 300最长递增子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/">https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/</a></p><h4 id="1、题目大意"><a href="#1、题目大意" class="headerlink" title="1、题目大意"></a>1、题目大意</h4><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg"></p><h4 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h4><p>看到题目，判断某一个数组的最长递增子序列，<strong>注意并不是连续的</strong>。</p><h4 id="3、方法1：完全递归"><a href="#3、方法1：完全递归" class="headerlink" title="3、方法1：完全递归"></a>3、方法1：完全递归</h4><ul><li><p>现在假设下标 <strong>i</strong> 结尾的数组的最唱递增子序列为 max，</p><p>若nums[i+1]&gt;nums[i] ; 则下标 <strong>i+1</strong> 结尾的数组的最唱递增子序列为 max+1，否则为 max</p></li><li><p>所以这个题目是可以拆解子问题的，有子问题最后堆砌到最终答案</p></li><li><p>设 函数  <strong>fun(n,nums)</strong>  : 表示在数组nums下，以n作为下标的最大递增序列</p><p>得到递归方程 ：<strong>fun(n,nums) = fun(j,nums)+1</strong> 其中 <strong>0&lt;=j&lt;i</strong> 并且 <strong>dp[j]&lt;dp[i] j为【0，i】</strong>里面的任意值，需要遍历</p></li><li><p>拿下图为递归树（简约哈）</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/2.png"></p></li><li><p><strong>代码：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int nums[] = &#123;10,9,2,5,3,7,101,18&#125;;</span><br><span class="line">    int numSize = sizeof(nums) / sizeof(nums[0]);</span><br><span class="line">    printf(&quot;%d&quot;,lengthOfLI(nums,numSize));</span><br><span class="line">&#125;</span><br><span class="line">//方法一完全递归</span><br><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    //直接遍历以每个下标的结尾的最大递增序列，再取其中的最大值</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 0; i &lt; numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = fmax(ans,fun(i,nums));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">//定义递归函数</span><br><span class="line">//fun(n,nums) : 表示在数组nums下，以n作为下标的最大递增序列</span><br><span class="line">//fun(n,nums) = fun(j,nums)+1 其中 0&lt;=j&lt;i 并且 dp[j]&lt;dp[i] j为[0，i]里面的任意值，需要遍历</span><br><span class="line">int fun(int n,int* nums)&#123;</span><br><span class="line">    //最大值</span><br><span class="line">    int ans = 1;</span><br><span class="line">    //递归出口,下标为0，即是返回1</span><br><span class="line">    if(n == 0)&#123;</span><br><span class="line">        ans = 1;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //按照递归方程开始，开始递归求解 </span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(nums[i]&lt;nums[n])&#123;</span><br><span class="line">            ans = fmax(ans,fun(i,nums)+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这样递归的结果就是，提交超时，hhhhhhh。但是没关系，思路对了，下面进行优化。</p><h4 id="4、方法2：记忆化加递归"><a href="#4、方法2：记忆化加递归" class="headerlink" title="4、方法2：记忆化加递归"></a>4、方法2：记忆化加递归</h4><ul><li><p>在方法一的基础上，我们可以记录一个记忆化的数组，在递归刚刚开始的时候去判断这个数组是否有值，有的话直接递归返回了，若没有，则进行递归</p></li><li><p>再拿上一张图片来看，比如递归到数字 2 的时候，我们记录好递归到数字 2 的记忆数组值，当下次在别的树枝上需要递归数字 2 的时候，便可以直接取了，而不用继续遍历了，效率会高很多</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/2.png"></p></li><li><p><strong>代码</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int nums[] = &#123;10,9,2,5,3,7,101,18&#125;;</span><br><span class="line">    int numSize = sizeof(nums) / sizeof(nums[0]);</span><br><span class="line">    printf(&quot;%d&quot;,lengthOfLI(nums,numSize));</span><br><span class="line">&#125;</span><br><span class="line">//方法二，在方法1的基础上：变为 递归+记忆化</span><br><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    //记忆化数组建立</span><br><span class="line">    int remenber[numsSize];</span><br><span class="line">    memset(remenber, -1,sizeof(int)* numsSize);</span><br><span class="line">    //直接遍历以每个下标的结尾的最大递增序列，再取其中的最大值</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 0; i &lt; numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = fmax(ans,fun1(i,nums,remenber));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">//定义递归函数</span><br><span class="line">//fun1(n,nums) : 表示在数组nums下，以n作为下标的最大递增序列</span><br><span class="line">//fun1(n,nums) = fun1(j,nums)+1  其中 0&lt;j&lt;n</span><br><span class="line">int fun1(int n,int* nums,int *remenber)&#123;</span><br><span class="line">    //先判断记忆化数组里面是否有这个值，有直接返回，不用继续递归了</span><br><span class="line">    if(remenber[n]!=-1)return remenber[n];</span><br><span class="line">    //最大值</span><br><span class="line">    int ans = 1;</span><br><span class="line">    //递归出口,下标为0，即是返回1</span><br><span class="line">    if(n == 0)&#123;</span><br><span class="line">        ans = 1;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //按照递归方程开始，开始递归求解 </span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(nums[i]&lt;nums[n])&#123;</span><br><span class="line">            ans = fmax(ans,fun1(i,nums,remenber)+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //同时添加到记忆化数组</span><br><span class="line">    remenber[n] = ans;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次提交，是可以通过的，足见时间效率上提高了可不少。</p><h4 id="5、方法3：动态规划"><a href="#5、方法3：动态规划" class="headerlink" title="5、方法3：动态规划"></a>5、方法3：动态规划</h4><ul><li><p>根据上述两个方法的分析的，可以很容易得到动态规划的状态转移方程</p></li><li><p>dp[i] : 表示以 i 为下标结尾的数组的最长递增字符串</p></li><li><p>状态转移方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[j]+1) 其中 0&lt;=j&lt;i 并且 dp[j]&lt;dp[i] j为[0，i]里面的任意值，需要遍历</span><br></pre></td></tr></table></figure></li><li><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int nums[] = &#123;10,9,2,5,3,7,101,18&#125;;</span><br><span class="line">    int numSize = sizeof(nums) / sizeof(nums[0]);</span><br><span class="line">    printf(&quot;%d&quot;,lengthOfLI(nums,numSize));</span><br><span class="line">&#125;</span><br><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    //最后的最大值</span><br><span class="line">    int ansMax = 1;</span><br><span class="line">    //1、建立dp数组</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    memset(dp, 0, sizeof(int) * numsSize);</span><br><span class="line">    //2、递归遍历，封装dp数组</span><br><span class="line">    for (int i = 0; i &lt; numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //记录遍历j属于【0，i】里面的最大值。初始值为1，表示本身</span><br><span class="line">        int max = 1;</span><br><span class="line">        for (int j = 0; j &lt; i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[j]&lt;nums[i]) max = fmax(max, dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //给dp赋值</span><br><span class="line">        dp[i] = max;</span><br><span class="line">        //每次比较，取最大</span><br><span class="line">        ansMax = dp[i] &gt; ansMax ? dp[i] : ansMax;</span><br><span class="line">    &#125;</span><br><span class="line">    return ansMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是比较常规的方法了：时间复杂度是 <strong>O（N*N）</strong></p></li></ul><h4 id="6、方法4：贪心-二分查找"><a href="#6、方法4：贪心-二分查找" class="headerlink" title="6、方法4：贪心+二分查找"></a>6、方法4：贪心+二分查找</h4><ul><li>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</li><li>基于上面的贪心思路，我们维护一个数组 dp[i] ，表示长度为 <strong>i</strong> 的最长上升子序列的末尾元素的最小值，用 <strong>len</strong> 记录目前最长上升子序列的长度，起始时**len =1，d[1]=nums[0]**。</li></ul><ul><li><p>由定义知dp数组必然是一个递增数组,  对原数组<strong>nums</strong>进行迭代, 依次判断每个数<strong>num</strong>将其插入dp数组相应的位置:</p><ol><li><strong>num &gt; dp[len]</strong>, 表示num比所有已知递增序列的尾数都大, 将num添加入dp 数组尾部, 并将最长递增序列长度len加1</li><li><strong>dp[i-1] &lt; num &lt;= dp[i]</strong>, 只更新相应的dp[i]=num</li></ol></li><li><p>以 nums=[4,10,3,8,9]：</p><p>1)第一步插入4，则 dp=[4]</p><ol start="2"><li><p>第二步插入10，则dp=[4，10]</p></li><li><p>第三步插入3，原数组4的位置更新为3 则dp=[4，10]==》dp=[3，10]</p></li><li><p>第四步插入8，原数组10的位置更新为8 则dp=[4，10]==》dp=[3，8]</p></li><li><p>第五步插入9，则dp=[3，8，9] </p></li></ol><p>所以最后的答案为 <strong>len(dp) = 3</strong>;</p></li><li><p><strong>代码：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int nums[] = &#123;10,9,2,5,3,7,101,18&#125;;</span><br><span class="line">    int numSize = sizeof(nums) / sizeof(nums[0]);</span><br><span class="line">    printf(&quot;%d&quot;,lengthOfLI3(nums,numSize));</span><br><span class="line">&#125;</span><br><span class="line">int lengthOfLI(int* nums, int numsSize)&#123;</span><br><span class="line">    //1、建立dp</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    memset(dp, 0, sizeof(int) * numsSize);</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        //直接二分查找dp中的第一个大于等于nums[i]的值</span><br><span class="line">        int left = 0, right = index;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if(dp[mid]&lt;nums[i])left = mid + 1;</span><br><span class="line">            else right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left] = nums[i];</span><br><span class="line">        if(right == index) index++;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="two-：354-俄罗斯套娃"><a href="#two-：354-俄罗斯套娃" class="headerlink" title="two ：354 俄罗斯套娃"></a>two ：354 俄罗斯套娃</h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><h4 id="1、题目大意-1"><a href="#1、题目大意-1" class="headerlink" title="1、题目大意"></a>1、题目大意</h4><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/3.jpg"></p><h4 id="2、分析-1"><a href="#2、分析-1" class="headerlink" title="2、分析"></a>2、分析</h4><ul><li><p>根据题目的要求，如果我们选择了 k 个信封，它们的</p></li><li><p>宽度依次为 w0, w1, ···, w k-1 高度依次为 h0, h1,···, h k-1 ，那么需要满足如下了两个条件：<br>$$<br>W0&lt;W1&lt;···&lt;Wk-1<br>$$</p><p>$$<br>h0&lt;h1&lt;···&lt;hk-1<br>$$</p><p>同时控制 w 和 h 两个维度并不是那么容易，因此我们考虑固定一个维度，再在另一个维度上进行选择。例如，我们固定 w 维度，那么我们将数组<strong>envelopes</strong> 中的所有信封按照 w 升序排序。这样一来，我们只要按照信封在数组中的出现顺序依次进行选取，就一定保证满足：<br>$$<br>W0≤W1≤···≤Wk-1<br>$$</p></li><li><p>然而小于等于 ≤ 和小于 &lt;还是有区别的，但我们不妨首先考虑一个简化版本的问题：</p><p>如果我们保证所有信封的 w 值互不相同，那么我们可以设计出一种得到答案的方法吗？</p><p>在 w 值互不相同的前提下，小于等于≤ 和小于 &lt; 是等价的，那么我们在排序后，就可以完全忽略 w 维度，只需要考虑 h 维度了。此时，我们需要解决的问题即为：</p><p>给定一个序列，我们需要找到一个最长的子序列，使得这个子序列中的元素严格单调递增，即上面要求的：</p><p>$$<br>h0&lt;h1&lt;···&lt;hk-1<br>$$</p><p>那么这个问题就是经典的「最长严格递增子序列」问题，问题得到解决，</p></li><li><p>当我们解决了简化版本的问题之后，我们来想一想使用上面的方法解决原问题，会产生什么错误？当 w 值相同时，如果我们不规定 h 值的排序顺序，那么可能会有如下的情况：</p><p>排完序的结果为 [(w, h)] = [(1, 1), (1, 2), (1, 3), (1, 4)][(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的 w 值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 1 个信封。然而如果我们完全忽略 w 维度，剩下的 h 维度为 [1, 2, 3, 4][1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的 4 个信封了，这就产生了错误。</p><p>因此，我们必须要保证对于每一种 w 值，我们最多只能选择 1 个信封。</p><p>我们可以将 h 值作为排序的第二关键字进行降序排序，这样一来，对于每一种 w 值，其对应的信封在排序后的数组中是按照 h 值递减的顺序出现的，那么这些 h 值不可能组成长度超过 1 的严格递增的序列，这就从根本上杜绝了错误的出现。</p></li><li><p>因此我们就可以得到解决本题需要的方法：</p><ul><li><p>首先我们将所有的信封按照 w 值第一关键字升序、h 值第二关键字降序进行排序；</p></li><li><p>随后我们就可以忽略 w 维度，求出 h 维度的最长严格递增子序列，其长度即为答案。</p></li></ul></li><li><p>至此分析完了，归根到底就是<strong>最长递增子序列</strong>的问题了</p></li></ul><h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><p><em><strong>直接show code no say say</strong></em></p><ul><li><p>常规动态规划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int* p[4];</span><br><span class="line">    int points[4][4] = &#123;&#123;5,4&#125;,&#123;6,4&#125;,&#123;6,7&#125;,&#123;2,3&#125;&#125;;</span><br><span class="line">    p[0] = &amp;points[0][0];</span><br><span class="line">    p[1] = &amp;points[1][0];</span><br><span class="line">    p[2] = &amp;points[2][0];</span><br><span class="line">    p[3] = &amp;points[3][0];</span><br><span class="line">    int envelopesSize = 4;</span><br><span class="line">    int envelopesColSize[] = &#123;2,2,2,2&#125;;</span><br><span class="line">    int ans = maxEnvelopes1(p,envelopesSize,envelopesColSize);</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">//方法一：普通动态规划</span><br><span class="line">//dp[i]：表示以下标i为结尾的最大增序列  再次遍历取其最大</span><br><span class="line">//状态转移方程 dp[i] = dp[j]+1 其中 j&lt;i 并且排好序的envelopes中envelopes[j][1]     &lt;envelopes[i][1] </span><br><span class="line">int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize)&#123;</span><br><span class="line">    //1、先排序，首先按照第一列升序排序，若第一列的值相同，则按照第二列的值降序排序</span><br><span class="line">    qsort(envelopes, envelopesSize, sizeof(int*), compare);</span><br><span class="line">    //2、构建dp数组</span><br><span class="line">    int dp[envelopesSize+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0]) * (envelopesSize + 1));</span><br><span class="line">    //3、根据状态转移方程，递推求dp</span><br><span class="line">    for (int i = 1; i &lt;= envelopesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历【1，i】位置 找符合条件的最大dp[j]+1</span><br><span class="line">        int max = 1;</span><br><span class="line">        for (int j = 1; j &lt; i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(envelopes[i-1][1]&gt;envelopes[j-1][1]) max = fmax(max, dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //赋值给dp</span><br><span class="line">        dp[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    //4、取其最大</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 0; i &lt; sizeof(dp) / sizeof(dp[0]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = dp[i] &gt; ans ? dp[i] : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第一个参数升序 第二个参数降序</span><br><span class="line">int compare(const void *a, const void *b)&#123;</span><br><span class="line">    int* num1 = *(int**)a;</span><br><span class="line">    int* num2 = *(int**)b;</span><br><span class="line">    if(num1[0]==num2[0]) return num2[1] - num1[1];</span><br><span class="line"> else  return num1[0] - num2[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>基于二分查找的动态规划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int* p[4];</span><br><span class="line">    int points[4][4] = &#123;&#123;5,4&#125;,&#123;6,4&#125;,&#123;6,7&#125;,&#123;2,3&#125;&#125;;</span><br><span class="line">    p[0] = &amp;points[0][0];</span><br><span class="line">    p[1] = &amp;points[1][0];</span><br><span class="line">    p[2] = &amp;points[2][0];</span><br><span class="line">    p[3] = &amp;points[3][0];</span><br><span class="line">    int envelopesSize = 4;</span><br><span class="line">    int envelopesColSize[] = &#123;2,2,2,2&#125;;</span><br><span class="line">    int ans = maxEnvelopes1(p,envelopesSize,envelopesColSize);</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">//方法二：基于二分查找的动态规划</span><br><span class="line">int maxEnvelopes1(int** envelopes, int envelopesSize, int* envelopesColSize) &#123;</span><br><span class="line">    if (envelopesSize == 0)  return 0;</span><br><span class="line">    //1、先排序，首先按照第一列升序排序，若第一列的值相同，则按照第二列的值降序排序</span><br><span class="line">    qsort(envelopes, envelopesSize, sizeof(int*), compare);</span><br><span class="line">    //2、构建dp数组</span><br><span class="line">    int dp[envelopesSize], indexSize = 0;</span><br><span class="line">    dp[indexSize++] = envelopes[0][1];</span><br><span class="line">    for (int i = 1; i &lt; envelopesSize; ++i) &#123;</span><br><span class="line">        int num = envelopes[i][1];</span><br><span class="line">        if (num &gt; dp[indexSize - 1])  dp[indexSize++] = num;</span><br><span class="line">        else &#123;</span><br><span class="line">            //在dp中寻找第一个大于等于num的值的下标，进而替换她</span><br><span class="line">            int index = lower_bound(dp, indexSize, num);</span><br><span class="line">            dp[index] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return indexSize;</span><br><span class="line">&#125;</span><br><span class="line">//二分查找</span><br><span class="line">int lower_bound(int* arr, int arrSize, int val) </span><br><span class="line">&#123;</span><br><span class="line">    int left = 0, right = arrSize - 1;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        int mid = (left + right) &gt;&gt; 1;</span><br><span class="line">        if (val &lt; arr[mid])  right = mid - 1;</span><br><span class="line">        else if (val &gt; arr[mid]) left = mid + 1;</span><br><span class="line">        else  return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[left] &gt;= val)  return left;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">//第一个参数升序 第二个参数降序</span><br><span class="line">int compare(const void *a, const void *b)&#123;</span><br><span class="line">    int* num1 = *(int**)a;</span><br><span class="line">    int* num2 = *(int**)b;</span><br><span class="line">    if(num1[0]==num2[0])&#123;</span><br><span class="line">        return num2[1] - num1[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num1[0] - num2[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="summary："><a href="#summary：" class="headerlink" title="summary："></a>summary：</h3><p>套路：遇到这种数组这种问题，经常想到以 <strong>下标i</strong> 为结尾作为的子问题，直接定义 <strong>dp【i】</strong>：为以 <strong>i</strong> 作为下标结尾的数组怎么怎么。。。。 </p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 子序列问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS和DFS模板</title>
      <link href="%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BFS%E5%92%8CDFS%E6%A8%A1%E6%9D%BF/"/>
      <url>%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BFS%E5%92%8CDFS%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>首先，总结一定的模板做题是十分有作用的，善于总结才是我们加强算法能力的表现。做总结可以提高我们的代码能力，可以比较快速解决算法问题，也会更加清晰算法的流程！！十分有必要！！</strong></p><p><strong>BFS的模板：</strong></p><ul><li>1、如果不需要确定当前遍历到了哪一层，BFS 模板如下。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while queue 不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    for 节点 in cur的所有相邻节点：</span><br><span class="line">        if 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure><ul><li>2、如果要确定当前遍历到了哪一层，BFS 模板如下。 这里增加了 level 表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size 表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level = 0</span><br><span class="line">while queue 不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    while (size --) &#123;</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        for 节点 in cur的所有相邻节点：</span><br><span class="line">            if 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure><p><strong>DFS模板（回溯）</strong></p><ul><li>1、最本质的法宝是“画图”，千万不能偷懒，拿纸和笔“画图”能帮助我们更好地分析递归结构，这个“递归结构”一般是“树形结构”，而符合题意的解正是在这个“树形结构”上进行一次“深度优先遍历”，这个过程有一个形象的名字，叫“搜索”；我们写代码也几乎是“看图写代码”，所以“画树形图”很重要。</li><li>2、然后使用一个状态变量，一般我习惯命名为 path、pre ，在这个“树形结构”上使用“深度优先遍历”，根据题目需要在适当的时候把符合条件的“状态”的值加入结果集；这个“状态”可能在叶子结点，也可能在中间的结点，也可能是到某一个结点所走过的路径。</li><li>3、在某一个结点有多个路径可以走的时候，使用循环结构。当程序递归到底返回到原来执行的结点时，“状态”以及与“状态”相关的变量需要“重置”成第 1 次走到这个结点的状态，这个操作有个形象的名字，叫“回溯”，“回溯”有“恢复现场”的意思：意即“回到当时的场景，已经走过了一条路，尝试走下一条路”。第 2 点中提到的状态通常是一个列表结构，因为一层一层递归下去，需要在列表的末尾追加，而返回到上一层递归结构，需要“状态重置”，因此要把列表的末尾的元素移除，符合这个性质的列表结构就是“栈”（只在一头操作）。</li><li>4、当我们明确知道一条路走不通的时候，例如通过一些逻辑计算可以推测某一个分支不能搜索到符合题意的结果，可以在循环中 continue 掉，这一步操作叫“剪枝”。“剪枝”的意义在于让程序尽量不要执行到更深的递归结构中，而又不遗漏符合题意的解。因为搜索的时间复杂度很高，“剪枝”操作得好的话，能大大提高程序的执行效率。“剪枝”通常需要对待搜索的对象做一些预处理，例如第 47 题、第 39 题、第 40 题、第 90 题需要对数组排序。“剪枝”操作也是这一类问题很难的地方，有一定技巧性。总结一下：“回溯” = “深度优先遍历” + “状态重置” + “剪枝”，写好“回溯”的前提是“画图”。因此，非要写一个模板，我想它可能长这个样子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(待搜索的集合, 递归到第几层, 状态变量 1, 状态变量 2, 结果集):</span><br><span class="line">    # 写递归函数都是这个套路：先写递归终止条件</span><br><span class="line">    if 可能是层数够深了:</span><br><span class="line">        # 打印或者把当前状态添加到结果集中</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 可以执行的分支路径 do           //分支路径</span><br><span class="line">        </span><br><span class="line">        # 剪枝</span><br><span class="line">        if 递归到第几层, 状态变量 1, 状态变量 2, 符合一定的剪枝条件:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        对状态变量状态变量 1, 状态变量 2 的操作（#）</span><br><span class="line">   </span><br><span class="line">        # 递归执行下一层的逻辑</span><br><span class="line">        backtrack(待搜索的集合, 递归到第几层, 状态变量 1, 状态变量 2, 结果集)</span><br><span class="line"></span><br><span class="line">        对状态变量状态变量 1, 状态变量 2 的操作（与标注了 # 的那一行对称，称为状态重置）</span><br><span class="line">        </span><br><span class="line">    end for</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小tips </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，简称DP）动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其<strong>记忆化</strong>存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈<strong>指数增长</strong>时特别有用。虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程很难统一，为了解决动态规划问题，只能靠多练习、多思考了。</p><p><em><strong>*动态规划问题满足三大重要性质*</strong></em></p><p><strong>最优子结构性质：</strong>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p><p><strong>子问题重叠性质：</strong>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p><p><strong>无后效性</strong>：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p><p><em><strong>重点</strong></em>   dp数组的含义 + 状态转移方程 （具体问题具体分析）</p><p><strong>首先背包问题是我们接触动态规划比不可取的经典问题，重要的问题说三遍，经典经典经典。</strong></p><ul><li>0-1背包问题</li><li>完全背包问题</li><li>多重背包问题</li></ul><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>​    这里你有N件物品和一个容量为M的背包，这N件物品的第 i 件物品的 价值是V[i] ，重量是W[i].问题是拿取这N件物品的哪几件时，使得背包可以装下（<u>意思就是物品的重量总和小于或等于M</u>）且价值最大。</p><p><strong>关键问题</strong>：其实这堆物品在你选择的时候无非就是两种路子可以选择：<strong>选 or 不选</strong></p><p>第一步：构建dp数组的含义，<code>dp[i][j]</code>  ：代表的是前 <strong>i</strong> 个物品加入容量为 <strong>j</strong> 的背包里面价值总和的最大值</p><p>第二步：分析状态转移方程</p><p>​    对于一个物品来说：要么选要么不选，</p><ul><li><p>选择这个物品：就是第<strong>i</strong>件物品放入背包中，此时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-w[i]] + V[i]   （j&gt;W[i]）</span><br></pre></td></tr></table></figure></li><li><p>不选择这个物品：就是舍弃第<strong>i</strong>件物品，不放入背包中，此时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure><p>经过这两步的分析，可以得出这个问题的状态转移方程（即为重要，very very important）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i-1][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 4; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,2,4,3,7&#125;; //物品的价值 前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,5,5&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&lt;W[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];  //装不下第i件物品，只能不要咯</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i - 1][j], dp[i - 1][j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、深入分析理解"><a href="#3、深入分析理解" class="headerlink" title="3、深入分析理解"></a>3、深入分析理解</h3><p>这个代码就是自下而上的方法，思路也是比较简单，就是不断遍历，不断填充dp表：</p><p>第一：初始化时候的表格：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti1.jpg"></p><p>第二：当 <strong>i</strong>=1的时候，只有物品1能够选择，如果背白容量够的话，那么此时的最大价值就是物品1的价值了</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti2.jpg"></p><p>第三：当<strong>i</strong>=2的时候，根据状态转移方程，此时取<strong>i</strong>=2，<strong>j</strong>=3的时候有如下转换：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti3.jpg"></p><p>最后，根据这样的规则：逐一填表得：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti4.jpg"></p><p>这样，就可以得到最后的结果：13了，我们也可以根据状态转移方程方向得到选择的物品是第1 2 4号物品。</p><p>到此，分析时间复杂度为填表的时间为<strong>O(N*M)</strong>  ， 空间复杂度为<strong>O(N*M)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti5.jpg"></p><h3 id="4、优化"><a href="#4、优化" class="headerlink" title="4、优化"></a>4、优化</h3><p>在这个问题上，其实时间上没什么好优化的了，只能从空间上进行一点优化 ，</p><p>首先我们再看看状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i-1][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti6.jpg"></p><p>可以明显看出，在填<strong>i+1</strong>行的数据的时候，只用到了第<strong>i</strong>行的数据，根本就没有用到<strong>i-1</strong>行的数据，换句话说，填某一行的数据的时候只与其前一行有关，根据这个规律，我们就可以使用将二维dp降为一维dp，缩减空间。此所谓滚动数组。</p><p><strong>总结</strong>：<code>dp[i][j]</code>所依赖的值必须是没有更新的，所以后到前。（ps：完全背包正好相反）</p><p>此时状态转移方程  <code>dp[j]</code> : 表示容量不超过 <strong>j</strong> 的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Max(dp[j],dp[j-w[i]] + V[i])  j&gt;W[i]</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><p>和上面的代码有一点区别，在填充dp数组的第二层循环的时候，不应该从前到后（左到右），而应该从后到前（右到左），因为如果选择从前到后（左到右），会导致前面的值被修改，而后面的的值确实依赖前面的值的，要保证后面值得依赖是不变了。所以在第二轮扫描得时候需要从后到前扫描。（下图看做一行滴数据哈）</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti7.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 4; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,2,4,3,7&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,5,5&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化得</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = M; j &gt;= W[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度 <strong>O(N*M）</strong>    空间复杂度<strong>O(M)</strong>   空间复杂度优化了挺多哦</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 有N种物品和一个容量为M的背包，每种物品都就可以选择任意多个，第<strong>i</strong>种物品的价值为 V[i]，重量是 W[i]，求解：选哪些物品放入背包，可因使得这些物品的价值最大，并且体积总和不超过背包容量。</p><p><strong>分析：</strong></p><p>完全背包问题是在0-1背包问题的基础上略有不同，不同的是在0-1背包问题中，某一件物品要么取一件要么不取，但是在完全背包的问题中，某一件物品可以无限（任意）的取。</p><p>从物品的选择角度说也不是 **选 OR 不选 **的问题了，而是选 0 1 2 3 4 ，，，件的问题了，</p><p>默默嘀咕：曾经的我刚刚 接触的时候，贪心（有手就行），事实证明我还是年轻，打扰了，贪心解决不了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti8.jpg"></p><p><strong>动态规划方法：</strong></p><p>第一步：构建dp数组的含义，<code>dp[i][j]</code>  ：代表的是前 <strong>i</strong> 个物品加入容量为 <strong>j</strong> 的背包里面价值总和的最大值</p><p>第二步：分析状态转移方程</p><p>​    对于一件新的物品来说：可以选可以不选，</p><ul><li><p>选择这个新物品：此时（拿了 <strong>i</strong> 号物品，我们还是继续拿 <strong>i</strong> 号物品）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-w[i]] + V[i]   （j&gt;W[i]）</span><br></pre></td></tr></table></figure></li><li><p>不选择这个物品：就是舍弃全部的第 <strong>i</strong> 件物品，不放入背包中，此时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure><p>经过这两步的分析，可以得出这个问题的状态转移方程（即为重要，very very important）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,5,8&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//没有优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&lt;W[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];  //装不下第i件物品，只能不要咯</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //可以装下，可以选择 拿或者不拿  只是将 0-1背包问题中的 i-1 改为 i</span><br><span class="line">                dp[i][j] = fmax(dp[i - 1][j], dp[i][j - W[i]] + V[i]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解</strong> ： 其实这边也还可以利用另外一个状态转移方程解决（自个摸索把）直接给出答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]=max(f[i-1][j-k*V[i]]+k*W[i],f[i][j])     0&lt;=k*c[i]&lt;=j</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;5,8&#125;; //物品的价值</span><br><span class="line">    int W[] = &#123;5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//f[i][j]=max(f[i-1][j-k*V[i]]+k*W[i],f[i][j])     0&lt;=k*c[i]&lt;=j</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt;= M; j++)&#123;</span><br><span class="line">                for (int k = 0; k * V[i] &lt;= j; k++)&#123;</span><br><span class="line">                    dp[i+1][j] = fmax(dp[i+1][j], dp[i][j-k * V[i]] + k * W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、深入分析理解-1"><a href="#3、深入分析理解-1" class="headerlink" title="3、深入分析理解"></a>3、深入分析理解</h3><p>这边也可以画出表格来一步一步填这个表格的问题，自底向上，</p><p>第一步：初始化时的表格：</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti9.jpg"></p><p>第二步：在第 <strong>i</strong> 个物品的时候，我们其实可以选择上一层中的几个位置中价值最高的那一个，在这里M=10，所以只需要将两个数值进行比较，如果M大于10，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值.</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti10.jpg"></p><p>到此，分析时间复杂度为填表的时间为<strong>O(N*M)</strong>  ， 空间复杂度为<strong>O(N*M)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti11.jpg"></p><h3 id="4、优化-1"><a href="#4、优化-1" class="headerlink" title="4、优化"></a>4、优化</h3><p>优化思路和0-1背包问题一模一样的，就不在这里赘述了，直接上状态方程和代码。</p><p><strong>总结</strong>：<code>dp[i][j]</code>所依赖的值必须是已经更新的，所以前到后。（ps：0-1背包正好相反）</p><p><strong>状态转移方程为</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[j]=max(f[j-w[i]]+c[i], f[j]);</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,5,8&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax1(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化得</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = W[i]; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度 <strong>O(N*M）</strong>    空间复杂度<strong>O(M)</strong>   空间复杂度也是变成线性的了。</p><p><strong>注解</strong>：其实还有一个小优化</p><p>比如两件物品 ：<strong>i</strong>   <strong>j</strong>    当  <strong>i</strong> 物品的重量比 <strong>j</strong> 的重，但是 <strong>i</strong> 的价值确比 <strong>j</strong> 的低，那我们岂不是可以直接跳过 <strong>i</strong> 了，直接选择 <strong>j</strong> 物品了。道理很简单，难道这世界上会有人去买一个又贵又难吃的东西？（富豪除外）</p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p><strong>分析</strong></p><p>这里既不像0-1背包每种物品只有1件，也不像完全背包那样每种物品有无数件，而是限定来了每种物品的数量，并不是你想取多少就取多少，得看看人家有没有。</p><p>经过前面两个的分析，这个多重背包问题得状态转移方程和完全背包的状态转移方程岂不是一个爹娘的样子，<strong>就是K多了一个限制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i,j] = max(dp(i-1, j - V[i] * k) + P[i] * k); （0 &lt;= k * V[i] &lt;= j &amp;&amp; 0 &lt;= k &lt;= n[i]）</span><br></pre></td></tr></table></figure><h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[],int n[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 3; //不同物品的数量</span><br><span class="line">    int M = 15; //背包的容量</span><br><span class="line">    int V[] = &#123;3,4,5&#125;; //物品的价值</span><br><span class="line">    int W[] = &#123;2,3,4&#125;; //物品的重量</span><br><span class="line">    int n[] = &#123;4, 3, 2&#125;;//每种物品的个数</span><br><span class="line">    int re = seekMax(N, M, V, W,n);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//没有优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[],int n[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt;= M; j++)&#123;</span><br><span class="line">                //k限制了条件 不加限制就是我上面讲的完全背包问题中在我没有优化的时候提出的另外一个方程的解</span><br><span class="line">                for (int k = 0; k &lt;= n[i] &amp;&amp; k * V[i] &lt;= j; k++)&#123;  </span><br><span class="line">                    dp[i+1][j] = fmax(dp[i+1][j], dp[i][j-k * V[i]] + k * W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析就不再分析了，和前面的一模一样的</p><h3 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h3><ul><li>优化1：这边优化也可以项0-1背包和完全背包的样子，将dp二维数组改为一维的dp数组，改为滚动数组，这里不再赘述</li><li>优化2：这里有一个比较巧妙的方法，完美将多重背包问题顺利转为0-1背包的问题了。下面会详细讲解这个优化（鄙人比较pick）</li></ul><p>举个例子：比如有一种物品，她一共有8件，我们再取的时候可以取得 0 1 2 3 4 5 6 7 8 件这九种情况，但是我们在取得时候是不知道该取多少件得，这时候我们可以把这八件物品分堆，使得我们可以取得上述得九种情况的任意一种，所以分堆便是重点了，这里分堆采用2进制的方法进行分堆</p><p><strong>统一</strong>：分为 1 2 4 8 。。。总的减去前面的总和（因为最后一个并不一定是2的整数次幂）<br>$$<br>n = 2^0 + 2^1 + 2^2 + 2^3…+ 2^h+(n-2^c+1)<br>（其中 h=c-1）<br>$$<br>例如八件同一件物品：分为大小为 1 2 4 1 的四个堆即可，任意组合可以得到上述选择的九种可能，此时将这四个堆想象成0-1背包问题种的不一样的物品即可。 </p><p>状态转移方程和0-1背包相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[],int n[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 3; //不同物品的数量</span><br><span class="line">    int M = 15; //背包的容量</span><br><span class="line">    int V[] = &#123;0,3,4,5&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,4&#125;; //物品的重量</span><br><span class="line">    int n[] = &#123;0,4,3,2&#125;;//每种物品的个数</span><br><span class="line">    int re = seekMax(N, M, V, W,n);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[],int n[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建分堆后的价值和重量数组 这个大小可以根据题目给的数据范围来确定</span><br><span class="line">    int newW[N * 20];</span><br><span class="line">    int newV[M * 20]; </span><br><span class="line">    newW[0] = 0;</span><br><span class="line">    newV[0] = 0;</span><br><span class="line">    //先分堆 完善上面两个数组</span><br><span class="line">    int number = 0; //分堆后的总堆数</span><br><span class="line">    for (int i = 1; i &lt;= N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n[i];j *= 2)</span><br><span class="line">        &#123;</span><br><span class="line">            number++;</span><br><span class="line">            newW[number] = W[i] * j;</span><br><span class="line">            newV[number] = V[i] * j;</span><br><span class="line">            n[i] -= j;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后那个</span><br><span class="line">        if(n[i]&gt;0)&#123;</span><br><span class="line">            number++;</span><br><span class="line">            newW[number] = W[i] * n[i];</span><br><span class="line">            newV[number] = V[i] * n[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = M; j &gt;= newW[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - newW[i]] + newV[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此三个经典的背包问题解决啦。</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti13.jpg"></p><h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p>所谓混合背包的问题无非就是前面三种背包的杂糅操作，比如有的物品符合0-1背包（只能够取1件或者不取），有的物品符合完全背包问题（一件物品能够取任意件），有的物品符合多重背包问题（一种物品只能怪取限定件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">伪代码：</span><br><span class="line">for(i = 0 ;i&lt;N;i++)&#123;</span><br><span class="line">if i属于0-1背包问题 </span><br><span class="line">采用0-1解决方法</span><br><span class="line">else if i属于完全背包问题</span><br><span class="line">采用完全解决方法</span><br><span class="line">else if i属于多重背包问题</span><br><span class="line">采用多重解决方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti12.jpg"></p><p>上述三种经典背包问题可谓了解动态规划的经典之作了，其实三种背包问题 都是有着异曲同工之妙呀，认真解读会让自己了解的更加深刻，舒服。其实关于背包问题的变形变异还有很多类似的题目，后续加以继续撸。。。鄙人不才，若有误望指正，本文章也是采取一些其他博客的思路，谢谢各路大神。</p><p>解决拥有子问题的问题，可以有三个方法</p><ul><li>朴素递归 （效率很低）</li><li>递归 + 记忆化 （效率较高）</li><li>递推完善dp数组（效率最高）动态规划常用</li></ul><p><em><strong>重点</strong></em>   dp数组的含义 + 状态转移方程 （具体问题具体分析）</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>[]: <a href="https://blog.csdn.net/woshi250hua/article/details/7636866">https://blog.csdn.net/woshi250hua/article/details/7636866</a></p><p>这位好心的博主列举了一些背包模型的例子，可以利于自己继续练习</p><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti21.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程中无穷大常量(ox3f3f3f3f)的设定技巧</title>
      <link href="%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%A0%E7%A9%B7%E5%A4%A7%E5%B8%B8%E9%87%8F-ox3f3f3f3f-%E7%9A%84%E8%AE%BE%E5%AE%9A%E6%8A%80%E5%B7%A7/"/>
      <url>%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%A0%E7%A9%B7%E5%A4%A7%E5%B8%B8%E9%87%8F-ox3f3f3f3f-%E7%9A%84%E8%AE%BE%E5%AE%9A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="编程中无穷大常量的设定技巧"><a href="#编程中无穷大常量的设定技巧" class="headerlink" title="编程中无穷大常量的设定技巧"></a>编程中无穷大常量的设定技巧</h4><p>首先，在做某一些算法的时候，会很常求最大最小值一类的问题，通常我们会设置一个初始一个answer最大int类型的最大或者最小，然后每次比较取大取小即可。</p><p>其实如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况 下，0x7fffffff并不是一个好的选择。理由如下：</p><p>很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作：<br>if (d[u]+w[u][v]&lt;d[v]) d[v]=d[u]+w[u][v];<br>我们知道如果u,v之间没有边，那么w[u][v]=INF，如果我们的INF取0x7fffffff，那么d[u]+w[u][v]会溢出而变成负数， 我们的松弛操作便出错了，更一般的说，0x7fffffff不能满足“无穷大加一个有穷的数依然是无穷大”，它变成了一个很小的负数。</p><p>计算机不会表示出“无穷大”的概念，所以我们只能以一个定值来表示“最大”。那么使用什么值呢？</p><p>32-bit int举例，我们选择的最大应该满足两个条件</p><ul><li><strong>这个最大值真的很大，是和定义的最大值是同一个数量级的</strong></li><li><strong>这个最大值+这个最大值并不会溢出的，也就是无穷大嘉无穷大依然是无穷大</strong></li></ul><p>所以我们需要一个更好的家伙来顶替 0x7fffffff ，最严谨的办法当然是对无穷大进行特别处理而不是找一个很大很大的常量来代替它（或者说模拟 它），但是这样会让我们的编程过程变得很麻烦。</p><p>在我看的大佬上面，最精巧的无穷大常量取值是 0x3f3f3f3f，我不知道是谁最先开始使用这个精妙的常 量来做无穷大，自己也是学以致用，你还别说发现非常好用，而当我对这个常量做更深入的分析时，就发现它真的是非常精巧了。</p><p> 第一、0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和 0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</p><p>第二、由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷 大”），事实上 0x3f3f3f3f + 0x3f3f3f3f = 2122219134，这非常大但却没有超过32-bit int的表示范围，所以 0x3f3f3f3f 还满足了我们“无穷大加无穷大还是无穷大”的需求。</p><p>第三、0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用 <code>memset(a,0,sizeof(a))</code>这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的 初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为 memset 是按字节操作的，它能够对数组清 零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为 0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f 的每个字节都是0x3f！所 以要把一段内存全部置为无穷大，我们只需要<code>memset(a,0x3f,sizeof(a))</code>。所以在通常的场合下，0x3f3f3f3f 真的是一个非常棒的选择。</p><p>补充：memset以字节为单位进行填充，可以全部置为0，-1，和某个int类型的值四个字节都是一样的表示的数值，别问问就是巧合！！</p>]]></content>
      
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小tips </tag>
            
            <tag> 常量设定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp详解</title>
      <link href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E8%AF%A6%E8%A7%A3/"/>
      <url>%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="1、tcp协议的特点"><a href="#1、tcp协议的特点" class="headerlink" title="1、tcp协议的特点"></a>1、tcp协议的特点</h4><p>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP 是TCP/IP 体系中非常复杂的一个协议，主要特点如下：</p><ul><li><p>TCP 是面向连接的传输层协议。</p></li><li><p>每条TCP 连接只能有两个端点，每条TCP 连接只能是点对点的（一对一）。</p></li><li><p>TCP 提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。</p><ul><li><p>如何保证数据无差错、不丢失、不重复且有序的？有哪些机制来保证？</p><p>答：TCP 使用了校验、序号、确认和重传等机制来达到这一目的。</p></li></ul></li><li><p>TCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。</p><ul><li><p>为什么需要设置缓存，缓存的作用？ </p><p>答：发送缓存用来暂时存放以下数据：1.发送应用程序传送给发送方TCP 准备发送的数据；2.TCP已发送但尚未收到确认的数据。</p><p>接收缓存用来暂时存放以下数据：1.按序到达但尚未被接收应用程序读取的数据；2.不按序到达的数据。</p></li></ul></li><li><p>TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。</p><ul><li>一个字节占一个序号，每个报文段用第一个字节的序号来标识,例如，一报文段的序号字段值是301, 而携带的数据共有l00B, 表明本报文段的数据的最后一个字节的序号是400, 因此下一个报文段的数据序号应从401开始，也就是期望的下一个序号（确认号）。</li></ul></li></ul><h4 id="2、tcp报文段格式"><a href="#2、tcp报文段格式" class="headerlink" title="2、tcp报文段格式"></a>2、tcp报文段格式</h4><p><img src="https://www.hualigs.cn/image/60a3a18937d44.jpg"></p><p>部分字段解释：</p><ol><li><p>序号字段（就是seq）：序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号字段（就是ack）：是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N, 则表明到序号N-1为止的所有数据都已正确收到。（累积确认）</p></li><li><p>确认位ACK：只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK置1。</p></li><li><p>同步位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN= 1, ACK=0 时，表明这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN= 1, ACK=1。即SYN=1表示这是一个连接请求或连接接收报文。</p></li><li><p>终止位FIN (Finish) 。用来释放一个连接。FIN=1表明此报文段的发送方的数据已发送完毕了并要求释放传输连接。</p></li></ol><h4 id="3、tcp连接管理"><a href="#3、tcp连接管理" class="headerlink" title="3、tcp连接管理"></a>3、tcp连接管理</h4><p>TCP 是面向连接的协议，因此每个TCP 连接都有三个阶段：连接建立、数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常进行。</p><p>在TCP 连接建立的过程中，要解决以下三个问题：</p><ol><li><p>要使每一方都能够确知对方的存在。</p></li><li><p>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等）。</p></li><li><p>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</p></li></ol><p>每条TCP 连接唯一地被通信两端的两个端点（即两个套接字）确定。 端口拼接到IP地址即为套接字，tcp的连接采用的是客户机/服务器方式，主动发起连接建立的应用进程称为客户机，而被动等待连接建立的应用进程称为服务器。</p><h4 id="4、tcp连接的建立"><a href="#4、tcp连接的建立" class="headerlink" title="4、tcp连接的建立"></a>4、tcp连接的建立</h4><p><img src="https://www.hualigs.cn/image/60a3a1bfa6710.jpg"></p><ol><li><p>第一次握手：客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号seq = x（连接请求报文不携带数据，但要消耗一个序号）。</p></li><li><p>第二次握手：服务器的TCP 收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN 和ACK 位都被置为1, 确认号字段的值为x+1,并且服务器随机产生起始序号seq= y( 确认报文不携带数据，但也要消耗一个序号）。确认报文段同样不包含应用层数据。</p></li><li><p>第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK 标志位被置1, 序号字段为x+1, 确认号字段ack=y+1。该报文段可以携带数据，若不携带数据则不消耗序号 http中的tcp连接的第三次握手的报文段中就捎带了客户对万维网文档的请求 。成功进行以上三步后，就建立了TCP 连接，接下来就可以传送应用层数据。TCP 提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。</p></li></ol><p><strong>【总结】</strong></p><ul><li><ol><li>SYN = 1,ACK = 0,seq = x;</li></ol></li><li><ol start="2"><li>SYN = 1,ACK = 1,seq = y,ack = x+1;</li></ol></li><li><ol start="3"><li>SYN = 0,ACK = 1,seq = x+1,ack=y+1。</li></ol></li></ul><h4 id="5、tcp释放连接"><a href="#5、tcp释放连接" class="headerlink" title="5、tcp释放连接"></a>5、tcp释放连接</h4><p><img src="https://www.hualigs.cn/image/60a3a1dfde76f.jpg"></p><ol><li><p>第一次握手：客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP 连接，该报文段的FIN 标志位被置1, seq= u, 它等于前面已传送过的数据的最后一个字节的序号加1 (FIN 报文段即使不携带数据，也要消耗一个序号）。TCP是全双工的，即可以想象为一条TCP 连接上有两条数据通路。发送FIN 报文时，发送FIN 的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</p></li><li><p>第二次握手：服务器收到连接释放报文段后即发出确认，确认号是ack = u + 1, 而这个报文段自己的序号是v, 等千它前面已传送过的数据的最后一个字节的序号加1 。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处千半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</p></li><li><p>第三次握手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。</p></li><li><p>第四次握手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1, 确认号ack= w + 1, 序号seq= u + 1 。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命）后，A才进入连接关闭状态。</p></li></ol><p><strong>【总结】</strong></p><ul><li><ol><li>FIN = 1,seq = u;</li></ol></li><li><ol start="2"><li>ACK = 1,seq = v,ack = u+1;</li></ol></li><li><ol start="3"><li>FIN = 1,ACK = 1,seq = w,ack =u+1;(确认第一次的u)</li></ol></li><li><ol start="4"><li>ACK = 1,seq = u+1,ack = w+1。</li></ol></li></ul><p><strong>question one : 什么是SYN洪泛攻击？（三次握手机制有什么问题？）</strong></p><p>答：由于服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，攻击者发送TCP的SYN报文段，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p><strong>question two :为什么不采用“两次握手”建立连接呢？</strong></p><p>答：这主要是为了<strong>防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误</strong>。考虑下面这种情况。客户A 向服务器B 发出TCP 连接请求，第一个连接请求报文在网络的某个结点长时间滞留， A 超时后认为报文丢失，于是再重传一次连接请求， B 收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器B, 而B 认为A又发来连接请求，此时若使用“三次握手”，则B 向A 返回确认报文段，由于是一个失效的请求，因此A 不予理睬，建立连接失败。若采用的是“两次握手”，则这种情况下B 认为传输连接已经建立，并一直等待A 传输数据，而A 此时并无连接请求，因此不予理睬，这样就造成了B的资源白白浪费。</p><p><strong>question three :如果已经建立了连接，但是客户端突然出现故障了怎么办?</strong></p><p>答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><strong>question four :为什么连接的时候是三次握手，关闭的时候却是四次握手?</strong></p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。</p><p><strong>question four :为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p><p>答：1)虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum SegmentLifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。2)防止出现“已失效的连接请求报文段“（和上面的为啥不用二次握手类似）。A 在发送最后一个确认报文段后，再经过2MSL可保证本连接持续的时间内所产生的所有报文段从网络中消失.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="all/hello-world/"/>
      <url>all/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
