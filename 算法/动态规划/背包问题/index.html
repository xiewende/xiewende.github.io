<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>背包问题 | sevenboy</title><meta name="keywords" content="动态规划,0-1背包,完全背包,多重背包"><meta name="author" content="sevenboy"><meta name="copyright" content="sevenboy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="针对动态规划问题的经典问题之背包问题的详解">
<meta property="og:type" content="article">
<meta property="og:title" content="背包问题">
<meta property="og:url" content="https://sevenboy.online/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="sevenboy">
<meta property="og:description" content="针对动态规划问题的经典问题之背包问题的详解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg">
<meta property="article:published_time" content="2021-05-22T09:08:38.000Z">
<meta property="article:modified_time" content="2021-05-22T09:31:46.598Z">
<meta property="article:author" content="sevenboy">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="背包问题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sevenboy.online/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '背包问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-05-22 17:31:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/image/myself.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 家</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sevenboy</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 家</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">背包问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-22T09:08:38.000Z" title="发表于 2021-05-22 17:08:38">2021-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-22T09:31:46.598Z" title="更新于 2021-05-22 17:31:46">2021-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="背包问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（Dynamic Programming，简称DP）动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其<strong>记忆化</strong>存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈<strong>指数增长</strong>时特别有用。虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程很难统一，为了解决动态规划问题，只能靠多练习、多思考了。</p>
<p><strong><em>\</em>动态规划问题满足三大重要性质**</strong></p>
<p><strong>最优子结构性质：</strong>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
<p><strong>子问题重叠性质：</strong>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
<p><strong>无后效性</strong>：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
<p><strong><em>重点</em></strong>   dp数组的含义 + 状态转移方程 （具体问题具体分析）</p>
<p><strong>首先背包问题是我们接触动态规划比不可取的经典问题，重要的问题说三遍，经典经典经典。</strong></p>
<ul>
<li>0-1背包问题</li>
<li>完全背包问题</li>
<li>多重背包问题</li>
</ul>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>​    这里你有N件物品和一个容量为M的背包，这N件物品的第 i 件物品的 价值是V[i] ，重量是W[i].问题是拿取这N件物品的哪几件时，使得背包可以装下（<u>意思就是物品的重量总和小于或等于M</u>）且价值最大。</p>
<p><strong>关键问题</strong>：其实这堆物品在你选择的时候无非就是两种路子可以选择：<strong>选 or 不选</strong></p>
<p>第一步：构建dp数组的含义，<code>dp[i][j]</code>  ：代表的是前 <strong>i</strong> 个物品加入容量为 <strong>j</strong> 的背包里面价值总和的最大值</p>
<p>第二步：分析状态转移方程</p>
<p>​    对于一个物品来说：要么选要么不选，</p>
<ul>
<li><p>选择这个物品：就是第<strong>i</strong>件物品放入背包中，此时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-w[i]] + V[i]   （j&gt;W[i]）</span><br></pre></td></tr></table></figure>
</li>
<li><p>不选择这个物品：就是舍弃第<strong>i</strong>件物品，不放入背包中，此时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure>
<p>经过这两步的分析，可以得出这个问题的状态转移方程（即为重要，very very important）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i-1][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 4; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,2,4,3,7&#125;; //物品的价值 前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,5,5&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&lt;W[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];  //装不下第i件物品，只能不要咯</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i - 1][j], dp[i - 1][j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、深入分析理解"><a href="#3、深入分析理解" class="headerlink" title="3、深入分析理解"></a>3、深入分析理解</h3><p>这个代码就是自下而上的方法，思路也是比较简单，就是不断遍历，不断填充dp表：</p>
<p>第一：初始化时候的表格：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti1.jpg" alt=""></p>
<p>第二：当 <strong>i</strong>=1的时候，只有物品1能够选择，如果背白容量够的话，那么此时的最大价值就是物品1的价值了</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti2.jpg" alt=""></p>
<p>第三：当<strong>i</strong>=2的时候，根据状态转移方程，此时取<strong>i</strong>=2，<strong>j</strong>=3的时候有如下转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti3.jpg" alt=""></p>
<p>最后，根据这样的规则：逐一填表得：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti4.jpg" alt=""></p>
<p>这样，就可以得到最后的结果：13了，我们也可以根据状态转移方程方向得到选择的物品是第1 2 4号物品。</p>
<p>到此，分析时间复杂度为填表的时间为<strong>O(N*M)</strong>  ， 空间复杂度为<strong>O(N*M)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti5.jpg" alt=""></p>
<h3 id="4、优化"><a href="#4、优化" class="headerlink" title="4、优化"></a>4、优化</h3><p>在这个问题上，其实时间上没什么好优化的了，只能从空间上进行一点优化 ，</p>
<p>首先我们再看看状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i-1][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti6.jpg" alt=""></p>
<p>可以明显看出，在填<strong>i+1</strong>行的数据的时候，只用到了第<strong>i</strong>行的数据，根本就没有用到<strong>i-1</strong>行的数据，换句话说，填某一行的数据的时候只与其前一行有关，根据这个规律，我们就可以使用将二维dp降为一维dp，缩减空间。此所谓滚动数组。</p>
<p><strong>总结</strong>：<code>dp[i][j]</code>所依赖的值必须是没有更新的，所以后到前。（ps：完全背包正好相反）</p>
<p>此时状态转移方程  <code>dp[j]</code> : 表示容量不超过 <strong>j</strong> 的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = Max(dp[j],dp[j-w[i]] + V[i])  j&gt;W[i]</span><br></pre></td></tr></table></figure>
<p><strong>代码实现：</strong></p>
<p>和上面的代码有一点区别，在填充dp数组的第二层循环的时候，不应该从前到后（左到右），而应该从后到前（右到左），因为如果选择从前到后（左到右），会导致前面的值被修改，而后面的的值确实依赖前面的值的，要保证后面值得依赖是不变了。所以在第二轮扫描得时候需要从后到前扫描。（下图看做一行滴数据哈）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti7.jpg" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 4; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,2,4,3,7&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,5,5&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化得</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = M; j &gt;= W[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时时间复杂度 <strong>O(N*M）</strong>    空间复杂度<strong>O(M)</strong>   空间复杂度优化了挺多哦</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 有N种物品和一个容量为M的背包，每种物品都就可以选择任意多个，第<strong>i</strong>种物品的价值为 V[i]，重量是 W[i]，求解：选哪些物品放入背包，可因使得这些物品的价值最大，并且体积总和不超过背包容量。</p>
<p><strong>分析：</strong></p>
<p>完全背包问题是在0-1背包问题的基础上略有不同，不同的是在0-1背包问题中，某一件物品要么取一件要么不取，但是在完全背包的问题中，某一件物品可以无限（任意）的取。</p>
<p>从物品的选择角度说也不是 <strong>选 OR 不选 </strong>的问题了，而是选 0 1 2 3 4 ，，，件的问题了，</p>
<p>默默嘀咕：曾经的我刚刚 接触的时候，贪心（有手就行），事实证明我还是年轻，打扰了，贪心解决不了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti8.jpg" alt=""></p>
<p><strong>动态规划方法：</strong></p>
<p>第一步：构建dp数组的含义，<code>dp[i][j]</code>  ：代表的是前 <strong>i</strong> 个物品加入容量为 <strong>j</strong> 的背包里面价值总和的最大值</p>
<p>第二步：分析状态转移方程</p>
<p>​    对于一件新的物品来说：可以选可以不选，</p>
<ul>
<li><p>选择这个新物品：此时（拿了 <strong>i</strong> 号物品，我们还是继续拿 <strong>i</strong> 号物品）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-w[i]] + V[i]   （j&gt;W[i]）</span><br></pre></td></tr></table></figure>
</li>
<li><p>不选择这个物品：就是舍弃全部的第 <strong>i</strong> 件物品，不放入背包中，此时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure>
<p>经过这两步的分析，可以得出这个问题的状态转移方程（即为重要，very very important）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Max(dp[i-1][j],dp[i][j-w[i]] + V[i])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,5,8&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//没有优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&lt;W[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];  //装不下第i件物品，只能不要咯</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //可以装下，可以选择 拿或者不拿  只是将 0-1背包问题中的 i-1 改为 i</span><br><span class="line">                dp[i][j] = fmax(dp[i - 1][j], dp[i][j - W[i]] + V[i]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解</strong> ： 其实这边也还可以利用另外一个状态转移方程解决（自个摸索把）直接给出答案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]=max(f[i-1][j-k*V[i]]+k*W[i],f[i][j])     0&lt;=k*c[i]&lt;=j</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;5,8&#125;; //物品的价值</span><br><span class="line">    int W[] = &#123;5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//f[i][j]=max(f[i-1][j-k*V[i]]+k*W[i],f[i][j])     0&lt;=k*c[i]&lt;=j</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt;= M; j++)&#123;</span><br><span class="line">                for (int k = 0; k * V[i] &lt;= j; k++)&#123;</span><br><span class="line">                    dp[i+1][j] = fmax(dp[i+1][j], dp[i][j-k * V[i]] + k * W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、深入分析理解-1"><a href="#3、深入分析理解-1" class="headerlink" title="3、深入分析理解"></a>3、深入分析理解</h3><p>这边也可以画出表格来一步一步填这个表格的问题，自底向上，</p>
<p>第一步：初始化时的表格：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti9.jpg" alt=""></p>
<p>第二步：在第 <strong>i</strong> 个物品的时候，我们其实可以选择上一层中的几个位置中价值最高的那一个，在这里M=10，所以只需要将两个数值进行比较，如果M大于10，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti10.jpg" alt=""></p>
<p>到此，分析时间复杂度为填表的时间为<strong>O(N*M)</strong>  ， 空间复杂度为<strong>O(N*M)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti11.jpg" alt=""></p>
<h3 id="4、优化-1"><a href="#4、优化-1" class="headerlink" title="4、优化"></a>4、优化</h3><p>优化思路和0-1背包问题一模一样的，就不在这里赘述了，直接上状态方程和代码。</p>
<p><strong>总结</strong>：<code>dp[i][j]</code>所依赖的值必须是已经更新的，所以前到后。（ps：0-1背包正好相反）</p>
<p><strong>状态转移方程为</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[j]=max(f[j-w[i]]+c[i], f[j]);</span><br></pre></td></tr></table></figure>
<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 2; //物品的数量</span><br><span class="line">    int M = 10; //背包的容量</span><br><span class="line">    int V[] = &#123;0,5,8&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,5,7&#125;; //物品的重量</span><br><span class="line">    int re = seekMax1(N, M, V, W);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化得</span><br><span class="line">int seekMax(int N,int M,int V[],int W[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = W[i]; j &lt;= M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - W[i]] + V[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时时间复杂度 <strong>O(N*M）</strong>    空间复杂度<strong>O(M)</strong>   空间复杂度也是变成线性的了。</p>
<p><strong>注解</strong>：其实还有一个小优化</p>
<p>比如两件物品 ：<strong>i</strong>   <strong>j</strong>    当  <strong>i</strong> 物品的重量比 <strong>j</strong> 的重，但是 <strong>i</strong> 的价值确比 <strong>j</strong> 的低，那我们岂不是可以直接跳过 <strong>i</strong> 了，直接选择 <strong>j</strong> 物品了。道理很简单，难道这世界上会有人去买一个又贵又难吃的东西？（富豪除外）</p>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p><strong>分析</strong></p>
<p>这里既不像0-1背包每种物品只有1件，也不像完全背包那样每种物品有无数件，而是限定来了每种物品的数量，并不是你想取多少就取多少，得看看人家有没有。</p>
<p>经过前面两个的分析，这个多重背包问题得状态转移方程和完全背包的状态转移方程岂不是一个爹娘的样子，<strong>就是K多了一个限制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i,j] = max(dp(i-1, j - V[i] * k) + P[i] * k); （0 &lt;= k * V[i] &lt;= j &amp;&amp; 0 &lt;= k &lt;= n[i]）</span><br></pre></td></tr></table></figure>
<h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[],int n[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 3; //不同物品的数量</span><br><span class="line">    int M = 15; //背包的容量</span><br><span class="line">    int V[] = &#123;3,4,5&#125;; //物品的价值</span><br><span class="line">    int W[] = &#123;2,3,4&#125;; //物品的重量</span><br><span class="line">    int n[] = &#123;4, 3, 2&#125;;//每种物品的个数</span><br><span class="line">    int re = seekMax(N, M, V, W,n);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//没有优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[],int n[])</span><br><span class="line">&#123;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[N+1][M+1];</span><br><span class="line">    memset(dp, 0, sizeof(dp[0][0]) * (N + 1) * (M + 1)); //先全部置为0，因为c中会给随机值，很烦</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = 0;  //背包容量为0，你拿不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">     for (int j = 0; j &lt; N ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][j] = 0;  //你不拿物品价值最大都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt;= M; j++)&#123;</span><br><span class="line">                //k限制了条件 不加限制就是我上面讲的完全背包问题中在我没有优化的时候提出的另外一个方程的解</span><br><span class="line">                for (int k = 0; k &lt;= n[i] &amp;&amp; k * V[i] &lt;= j; k++)&#123;  </span><br><span class="line">                    dp[i+1][j] = fmax(dp[i+1][j], dp[i][j-k * V[i]] + k * W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析就不再分析了，和前面的一模一样的</p>
<h3 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h3><ul>
<li>优化1：这边优化也可以项0-1背包和完全背包的样子，将dp二维数组改为一维的dp数组，改为滚动数组，这里不再赘述</li>
<li>优化2：这里有一个比较巧妙的方法，完美将多重背包问题顺利转为0-1背包的问题了。下面会详细讲解这个优化（鄙人比较pick）</li>
</ul>
<p>举个例子：比如有一种物品，她一共有8件，我们再取的时候可以取得 0 1 2 3 4 5 6 7 8 件这九种情况，但是我们在取得时候是不知道该取多少件得，这时候我们可以把这八件物品分堆，使得我们可以取得上述得九种情况的任意一种，所以分堆便是重点了，这里分堆采用2进制的方法进行分堆</p>
<p><strong>统一</strong>：分为 1 2 4 8 。。。总的减去前面的总和（因为最后一个并不一定是2的整数次幂）</p>
<script type="math/tex; mode=display">
n = 2^0 + 2^1 + 2^2 + 2^3...+ 2^h+(n-2^c+1)       
（其中 h=c-1）</script><p>例如八件同一件物品：分为大小为 1 2 4 1 的四个堆即可，任意组合可以得到上述选择的九种可能，此时将这四个堆想象成0-1背包问题种的不一样的物品即可。 </p>
<p>状态转移方程和0-1背包相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int seekMax(int N, int M, int V[], int W[],int n[]);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N = 3; //不同物品的数量</span><br><span class="line">    int M = 15; //背包的容量</span><br><span class="line">    int V[] = &#123;0,3,4,5&#125;; //物品的价值  前面的0就是占位的，方便遍历</span><br><span class="line">    int W[] = &#123;0,2,3,4&#125;; //物品的重量</span><br><span class="line">    int n[] = &#123;0,4,3,2&#125;;//每种物品的个数</span><br><span class="line">    int re = seekMax(N, M, V, W,n);</span><br><span class="line">    printf(&quot;%d&quot;, re);</span><br><span class="line">&#125;</span><br><span class="line">//优化的</span><br><span class="line">int seekMax(int N,int M,int V[],int W[],int n[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建分堆后的价值和重量数组 这个大小可以根据题目给的数据范围来确定</span><br><span class="line">    int newW[N * 20];</span><br><span class="line">    int newV[M * 20]; </span><br><span class="line">    newW[0] = 0;</span><br><span class="line">    newV[0] = 0;</span><br><span class="line">    //先分堆 完善上面两个数组</span><br><span class="line">    int number = 0; //分堆后的总堆数</span><br><span class="line">    for (int i = 1; i &lt;= N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n[i];j *= 2)</span><br><span class="line">        &#123;</span><br><span class="line">            number++;</span><br><span class="line">            newW[number] = W[i] * j;</span><br><span class="line">            newV[number] = V[i] * j;</span><br><span class="line">            n[i] -= j;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后那个</span><br><span class="line">        if(n[i]&gt;0)&#123;</span><br><span class="line">            number++;</span><br><span class="line">            newW[number] = W[i] * n[i];</span><br><span class="line">            newV[number] = V[i] * n[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1、创建dp数组</span><br><span class="line">    int dp[M+1];</span><br><span class="line">    //2、初始化dp数组</span><br><span class="line">     for (int j = 0; j &lt;= M  ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = 0;  //初始全部都为0</span><br><span class="line">    &#125;</span><br><span class="line">    //3、开始根据状态转移方程地推填满dp数组</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = M; j &gt;= newW[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = fmax(dp[j], dp[j - newW[i]] + newV[i]); //可以装下，可以选择 拿或者不拿</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此三个经典的背包问题解决啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti13.jpg" alt=""></p>
<h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p>所谓混合背包的问题无非就是前面三种背包的杂糅操作，比如有的物品符合0-1背包（只能够取1件或者不取），有的物品符合完全背包问题（一件物品能够取任意件），有的物品符合多重背包问题（一种物品只能怪取限定件）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">伪代码：</span><br><span class="line">for(i = 0 ;i&lt;N;i++)&#123;</span><br><span class="line">	if i属于0-1背包问题 </span><br><span class="line">		采用0-1解决方法</span><br><span class="line">	else if i属于完全背包问题</span><br><span class="line">		采用完全解决方法</span><br><span class="line">	else if i属于多重背包问题</span><br><span class="line">		采用多重解决方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti12.jpg" alt=""></p>
<p>上述三种经典背包问题可谓了解动态规划的经典之作了，其实三种背包问题 都是有着异曲同工之妙呀，认真解读会让自己了解的更加深刻，舒服。其实关于背包问题的变形变异还有很多类似的题目，后续加以继续撸。。。鄙人不才，若有误望指正，本文章也是采取一些其他博客的思路，谢谢各路大神。</p>
<p>解决拥有子问题的问题，可以有三个方法</p>
<ul>
<li>朴素递归 （效率很低）</li>
<li>递归 + 记忆化 （效率较高）</li>
<li>递推完善dp数组（效率最高）动态规划常用</li>
</ul>
<p><strong><em>重点</em></strong>   dp数组的含义 + 状态转移方程 （具体问题具体分析）</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>[]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/woshi250hua/article/details/7636866">https://blog.csdn.net/woshi250hua/article/details/7636866</a></p>
<p>这位好心的博主列举了一些背包模型的例子，可以利于自己继续练习</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti21.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sevenboy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sevenboy.online/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">https://sevenboy.online/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sevenboy.online" target="_blank">sevenboy</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a class="post-meta__tags" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BFS%E5%92%8CDFS%E6%A8%A1%E6%9D%BF/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210522/DFS%E5%92%8CBFS%E6%A8%A1%E6%9D%BF.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BFS和DFS模板</div></div></a></div><div class="next-post pull-right"><a href="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%A0%E7%A9%B7%E5%A4%A7%E5%B8%B8%E9%87%8F-ox3f3f3f3f-%E7%9A%84%E8%AE%BE%E5%AE%9A%E6%8A%80%E5%B7%A7/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210522/%E6%97%A0%E7%A9%B7%E5%A4%A7%E9%87%8F.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编程中无穷大常量(ox3f3f3f3f)的设定技巧</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/算法/动态规划/最长递增子序列/" title="最长递增子序列"><img class="cover" src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210523%E5%AD%90%E5%BA%8F%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-23</div><div class="title">最长递增子序列</div></div></a></div><div><a href="/算法/动态规划/马在棋盘上的概率/" title="马在棋盘上的概率"><img class="cover" src="https://cdn.jsdelivr.net/gh/xiewende/blog_img/20210524%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A6%82%E7%8E%87/%E9%A9%AC%E7%9A%84%E6%A6%82%E7%8E%87.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-24</div><div class="title">马在棋盘上的概率</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">0-1背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2、代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">3、深入分析理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">4、优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">3.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.2.</span> <span class="toc-text">2、代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3-1"><span class="toc-number">3.3.</span> <span class="toc-text">3、深入分析理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BC%98%E5%8C%96-1"><span class="toc-number">3.4.</span> <span class="toc-text">4、优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">多重背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">4.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.</span> <span class="toc-text">2、代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">3、优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">混合背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">附件</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/xiewende/blog_img/bag_problem/wenti%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 By sevenboy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">this is a sunshine body</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="阳光,向上,好学,积极,热爱,奋斗,拼搏,追求,奋发" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":180,"height":330},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>